/*
Copyright 2017 Google, Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package differs

import (
	"archive/tar"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"math/rand"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"

	pkgutil "github.com/GoogleCloudPlatform/container-diff/pkg/util"
	"github.com/GoogleCloudPlatform/container-diff/util"
	dockertar "github.com/containers/image/docker/tarfile"
	godocker "github.com/fsouza/go-dockerclient"
	"github.com/nightlyone/lockfile"
	"github.com/sirupsen/logrus"
)

// daemonMutex is required to protect against other go-routines, as
// nightlyone/lockfile implements a recursive lock, which doesn't protect
// against other go-routines that have the same PID.  Note that the mutex
// *must* always be locked prior to the lockfile, and unlocked after.
var daemonMutex sync.Mutex

type RPMAnalyzer struct {
}

// Name returns the name of the analyzer.
func (a RPMAnalyzer) Name() string {
	return "RPMAnalyzer"
}

// Diff compares the installed rpm packages of image1 and image2.
func (a RPMAnalyzer) Diff(image1, image2 pkgutil.Image) (util.Result, error) {
	diff, err := singleVersionDiff(image1, image2, a)
	return diff, err
}

// Analyze collects information of the installed rpm packages on image.
func (a RPMAnalyzer) Analyze(image pkgutil.Image) (util.Result, error) {
	analysis, err := singleVersionAnalysis(image, a)
	return analysis, err
}

// getPackages returns a map of installed rpm package on image.
func (a RPMAnalyzer) getPackages(image pkgutil.Image) (map[string]util.PackageInfo, error) {
	path := image.FSPath
	packages := make(map[string]util.PackageInfo)
	if _, err := os.Stat(path); err != nil {
		// invalid image directory path
		return packages, err
	}

	// try to find the rpm binary in bin/ or usr/bin/
	rpmBinary := filepath.Join(path, "bin/rpm")
	if _, err := os.Stat(rpmBinary); err != nil {
		rpmBinary = filepath.Join(path, "usr/bin/rpm")
		if _, err = os.Stat(rpmBinary); err != nil {
			logrus.Errorf("Could not detect RPM binary in unpacked image %s", image.Source)
			return packages, nil
		}
	}

	return rpmDataFromContainer(image)
}

// rpmDataFromContainer runs image in a container, queries the data of
// installed rpm packages and returns a map of packages.
func rpmDataFromContainer(image pkgutil.Image) (map[string]util.PackageInfo, error) {
	packages := make(map[string]util.PackageInfo)

	client, err := godocker.NewClientFromEnv()
	if err != nil {
		return packages, err
	}

	// if image is a tar archive, we need to load it
	imageName := image.Source
	if image.IsTar() {
		// NOTE: all work below is only required for multilayer tar
		// archives generated by `docker save`.  Flat file-system
		// archives generated by `docker create` can just be imported
		// without potential name conflicts.  However, those are not
		// supported yet.
		if err := lock(); err != nil {
			return packages, err
		}

		archive, err := generateNewArchive(imageName)
		if err != nil {
			logrus.Errorf(err.Error())
		}
		defer os.Remove(archive)

		imageName, err = loadArchiveToDaemon(archive)
		if err != nil {
			return packages, fmt.Errorf("Error loading archive: %s", err)
		}
		unlock()

		defer client.RemoveImage(imageName)
		defer logrus.Infof("Removing image %s", imageName)
	} else if image.IsCloud() {
		// if it's a remote image we pull it unconditionally and avoid
		// name/tag conflicts by pulling it via its sha256 digest
		var buf bytes.Buffer
		digest, err := image.GetRemoteDigest()
		if err != nil {
			return packages, err
		}
		imageName = image.GetName() + "@" + digest
		logrus.Infof("Pulling remote image %s", imageName)
		pullOpts := godocker.PullImageOptions{
			Repository:   imageName,
			OutputStream: &buf,
		}
		if err := client.PullImage(pullOpts, godocker.AuthConfiguration{}); err != nil {
			return packages, fmt.Errorf("Error pulling remote image %s: %s", imageName, err)
		}
		// log PullImage() output in debug mode
		if logrus.GetLevel() == logrus.DebugLevel {
			// log each line separately for consistency
			for _, out := range strings.Split(buf.String(), "\n") {
				if len(out) > 0 {
					logrus.Debug(out)
				}
			}
		}
		defer client.RemoveImage(imageName)
	}

	contConf := godocker.Config{
		Cmd:   []string{"rpm", "--nodigest", "--nosignature", "-qa", "--qf", "%{NAME}\t%{VERSION}\t%{SIZE}\n"},
		Image: imageName,
	}

	hostConf := godocker.HostConfig{
		AutoRemove: true,
	}

	contOpts := godocker.CreateContainerOptions{Config: &contConf}
	container, err := client.CreateContainer(contOpts)
	if err != nil {
		return packages, err
	}
	logrus.Infof("Created container %s", container.ID)

	removeOpts := godocker.RemoveContainerOptions{
		ID: container.ID,
	}
	defer client.RemoveContainer(removeOpts)

	if err := client.StartContainer(container.ID, &hostConf); err != nil {
		return packages, err
	}

	exitCode, err := client.WaitContainer(container.ID)
	if err != nil {
		return packages, err
	}

	outBuf := new(bytes.Buffer)
	errBuf := new(bytes.Buffer)
	logOpts := godocker.LogsOptions{
		Context:      context.Background(),
		Container:    container.ID,
		Stdout:       true,
		Stderr:       true,
		OutputStream: outBuf,
		ErrorStream:  errBuf,
	}

	if err := client.Logs(logOpts); err != nil {
		return packages, err
	}

	if exitCode != 0 {
		return packages, fmt.Errorf("non-zero exit code %d: %s", exitCode, errBuf.String())
	}

	output := strings.Split(outBuf.String(), "\n")
	return parsePackageData(output)
}

// parsePackageData parses the package data of each line in rpmOutput and
// returns a map of packages.
func parsePackageData(rpmOutput []string) (map[string]util.PackageInfo, error) {
	packages := make(map[string]util.PackageInfo)

	for _, output := range rpmOutput {
		spl := strings.Split(output, "\t")
		if len(spl) != 3 {
			// ignore the empty (last) line
			if output != "" {
				logrus.Errorf("unexpected rpm-query output: '%s'", output)
			}
			continue
		}
		pkg := util.PackageInfo{}

		var err error
		pkg.Size, err = strconv.ParseInt(spl[2], 10, 64)
		if err != nil {
			return packages, fmt.Errorf("error converting package size: %s", spl[2])
		}

		pkg.Version = spl[1]
		packages[spl[0]] = pkg
	}

	return packages, nil
}

// loadArchiveToDaemon loads the image specified by archive to the docker
// Daemon.
func loadArchiveToDaemon(archive string) (string, error) {
	client, err := godocker.NewClientFromEnv()
	if err != nil {
		return "", err
	}

	inBuf, err := os.Open(archive)
	if err != nil {
		return "", err
	}

	outBuf := new(bytes.Buffer)
	loadOpts := godocker.LoadImageOptions{
		InputStream:  inBuf,
		OutputStream: outBuf,
		Context:      context.Background(),
	}
	if err := client.LoadImage(loadOpts); err != nil {
		return "", err
	}

	// output has the form "Loaded image: repository:tag"
	output := outBuf.String()
	spl := strings.Split(output, ": ")
	if len(spl) != 2 {
		return "", fmt.Errorf("unexpected docker load output: %s", output)
	}
	image := strings.TrimSpace(spl[1])
	logrus.Infof("Loaded %s as image %s", archive, image)

	return image, nil
}

// updateRepoTagsFromManifest updates the RepoTags in the manifest.json with a
// unique tag in the `containerdiff` image namespace.  There is a maximum of 10
// tries to generate a unique tag.
func updateRepoTagsFromManifest(r io.Reader) ([]byte, error) {
	f, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}

	var manifestItems []dockertar.ManifestItem
	if err := json.Unmarshal(f, &manifestItems); err != nil {
		return nil, fmt.Errorf("error unmarshalling manifest: %s", err)
	}

	// error out in case the tar ships multiple images
	if len(manifestItems) != 1 {
		return nil, fmt.Errorf("tar archive ships %d images, but only 1 is supported", len(manifestItems))
	}

	client, err := godocker.NewClientFromEnv()
	if err != nil {
		return nil, err
	}

	tag := ""
	rand.Seed(time.Now().UnixNano())
	for i := 0; i < 10; i++ {
		tag = "containerdiff:" + strconv.FormatUint(rand.Uint64(), 10)
		logrus.Debugf("generated new random tag: %s", tag)
		if _, err := client.InspectImage(tag); err != nil {
			break
		}
		tag = ""
	}
	if len(tag) == 0 {
		return nil, fmt.Errorf("failed to generate unique tag: too many tries")
	}

	// Overwrite the `RepoTags` member with a unique tag, which determines
	// the image's tag after being loaded by the Docker daemon.
	// Unfortunately, `docker load` does not generate a new tag in case of
	// a conflict, but it will rename the already present image.  We avoid
	// such conflicts by generating a unique tag in the `containerdiff:`
	// namespace and by updating the manifest.json file in the tar archive.
	manifestItems[0].RepoTags = []string{tag}

	return json.Marshal(manifestItems)
}

// generateNewArchive updates archive's manifest and returns the path of the
// newly generated archive.
func generateNewArchive(archive string) (string, error) {
	// tar reader
	f, err := os.Open(archive)
	if err != nil {
		return "", err
	}
	defer f.Close()
	tr := tar.NewReader(f)

	// tar writer
	tmpfile, err := ioutil.TempFile("", "containerdiff-archive")
	if err != nil {
		return "", err
	}
	defer tmpfile.Close()
	tw := tar.NewWriter(tmpfile)

	for {
		hdr, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return "", err
		}

		// update the manifest
		switch t := hdr.Typeflag; t {
		case tar.TypeReg:
			if hdr.Name == "manifest.json" {
				newManifest, err := updateRepoTagsFromManifest(tr)
				if err != nil {
					return "", err
				}
				hdr.Size = int64(len(newManifest))
				if err := tw.WriteHeader(hdr); err != nil {
					return "", err
				}
				if _, err := tw.Write(newManifest); err != nil {
					return "", err
				}
				continue
			}
		}

		if err := tw.WriteHeader(hdr); err != nil {
			return "", err
		}
		if _, err := io.Copy(tw, tr); err != nil {
			return "", err
		}
	}

	return tmpfile.Name(), nil
}

// unlock returns the containerdiff file-system lock.  It is placed in the
// system's temporary directory to make sure it's accessible for all users in
// the system; no root required.
func getLockfile() (lockfile.Lockfile, error) {
	lockPath := filepath.Join(os.TempDir(), ".containerdiff.lock")
	lock, err := lockfile.New(lockPath)
	if err != nil {
		return lock, err
	}
	return lock, nil
}

// lock acquires the containerdiff file-system lock.
func lock() error {
	var err error
	var lock lockfile.Lockfile

	daemonMutex.Lock()
	lock, err = getLockfile()
	if err != nil {
		daemonMutex.Unlock()
		return fmt.Errorf("[lock] cannot init lockfile: %v", err)
	}

	// Try to acquire the lock and in case of a temporary error, sleep for
	// two seconds until the next retry (at most 10 times).  Return fatal
	// errors immediately, as we can't recover.
	for i := 0; i < 10; i++ {
		if err = lock.TryLock(); err != nil {
			switch err.(type) {
			case lockfile.TemporaryError:
				logrus.Debugf("[lock] busy: next retry in two seconds")
				time.Sleep(2 * time.Second)
			default:
				daemonMutex.Unlock()
				return fmt.Errorf("[lock] error acquiring lock: %s", err)
			}
		}
	}
	if err != nil {
		daemonMutex.Unlock()
		return fmt.Errorf("[lock] error acquiring lock: too many tries")
	}

	logrus.Debugf("[lock] lock acquired")
	return nil
}

// unlock releases the containerdiff file-system lock.  Note that errors can be
// ignored as there's no meaningful way to recover.
func unlock() error {
	lock, err := getLockfile()
	if err != nil {
		return fmt.Errorf("[unlock] cannot init lockfile: %v", err)
	}
	err = lock.Unlock()
	if err != nil {
		return fmt.Errorf("[unlock] error releasing lock: %s", err)
	}
	logrus.Debugf("[unlock] lock released")
	daemonMutex.Unlock()
	return nil
}
